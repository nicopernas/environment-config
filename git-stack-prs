#!/usr/bin/env bash

# git-stack-prs - Create stacked PRs from HEAD down to a specified tag/commit/branch
# Each PR is based on the previous commit, creating a stack of dependent PRs

set -eo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}INFO:${NC} $1"
}

print_success() {
    echo -e "${GREEN}SUCCESS:${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}WARNING:${NC} $1"
}

print_error() {
    echo -e "${RED}ERROR:${NC} $1"
}

# Function to show usage
show_usage() {
    echo "Usage: git-stack-prs <base-ref> [options]"
    echo ""
    echo "Creates stacked PRs for each commit from HEAD down to <base-ref>"
    echo ""
    echo "Arguments:"
    echo "  <base-ref>      Tag, commit ID, or branch name to use as base"
    echo ""
    echo "Options:"
    echo "  --dry-run       Show what would be done without creating PRs"
    echo "  --base-branch   Target branch for PRs (default: main)"
    echo "  --prefix        Prefix for branch names (default: current branch name)"
    echo "  --help          Show this help message"
    echo ""
    echo "Branch naming:"
    echo "  Branches are named as: {prefix}-{index}"
    echo "  If current branch is 'nico/foo', creates: nico/foo-0, nico/foo-1, etc."
    echo ""
    echo "Examples:"
    echo "  git-stack-prs v1.2.3                    # Create PRs from HEAD to tag v1.2.3"
    echo "  git-stack-prs abc123def                 # Create PRs from HEAD to commit abc123def"
    echo "  git-stack-prs main --dry-run            # Show what would happen without creating PRs"
    echo "  git-stack-prs v1.0.0 --base-branch dev  # Target 'dev' branch instead of 'main'"
    echo "  git-stack-prs v1.0.0 --prefix feature   # Use 'feature' prefix: feature-0, feature-1, etc."
    echo ""
    echo "Git integration:"
    echo "  You can also use as a git subcommand:"
    echo "  git stack-prs v1.2.3                    # Same as git-stack-prs v1.2.3"
}

# Parse command line arguments
BASE_REF=""
DRY_RUN=false
BASE_BRANCH="main"
BRANCH_PREFIX=""

while [[ $# -gt 0 ]]; do
    case $1 in
    --dry-run)
        DRY_RUN=true
        shift
        ;;
    --base-branch)
        BASE_BRANCH="$2"
        shift 2
        ;;
    --prefix)
        BRANCH_PREFIX="$2"
        shift 2
        ;;
    --help|-h)
        show_usage
        exit 0
        ;;
    -*)
        print_error "Unknown option: $1"
        show_usage
        exit 1
        ;;
    *)
        if [[ -z "$BASE_REF" ]]; then
            BASE_REF="$1"
        else
            print_error "Too many arguments"
            show_usage
            exit 1
        fi
        shift
        ;;
    esac
done

# Validate arguments
if [[ -z "$BASE_REF" ]]; then
    print_error "Base reference is required"
    show_usage
    exit 1
fi

# Check if we're in a git repository
if ! git rev-parse --git-dir >/dev/null 2>&1; then
    print_error "Not in a git repository"
    exit 1
fi

# Check if gh CLI is installed
if ! command -v gh &>/dev/null; then
    print_error "GitHub CLI (gh) is not installed. Please install it first."
    print_info "Visit: https://cli.github.com/"
    exit 1
fi

# Check if user is authenticated with gh
if ! gh auth status &>/dev/null; then
    print_error "Not authenticated with GitHub CLI. Please run 'gh auth login' first."
    exit 1
fi

# Validate that base ref exists
if ! git rev-parse --verify "$BASE_REF" >/dev/null 2>&1; then
    print_error "Base reference '$BASE_REF' does not exist"
    exit 1
fi

# Get commit hashes from HEAD down to base ref (excluding base ref)
print_info "Getting commits from HEAD to $BASE_REF..."
COMMITS=($(git rev-list --reverse "$BASE_REF..HEAD"))

if [[ ${#COMMITS[@]} -eq 0 ]]; then
    print_warning "No commits found between $BASE_REF and HEAD"
    exit 0
fi

print_info "Found ${#COMMITS[@]} commits to create PRs for"

# Get current branch name
CURRENT_BRANCH=$(git branch --show-current)
if [[ -z "$CURRENT_BRANCH" ]]; then
    print_error "Not on a branch (detached HEAD)"
    exit 1
fi

# Set branch prefix to current branch if not specified
if [[ -z "$BRANCH_PREFIX" ]]; then
    BRANCH_PREFIX="$CURRENT_BRANCH"
fi

# Ensure we're on the right starting point
git checkout HEAD >/dev/null 2>&1

print_info "Current branch: $CURRENT_BRANCH"
print_info "Base reference: $BASE_REF"
print_info "Target branch: $BASE_BRANCH"
print_info "Branch prefix: $BRANCH_PREFIX"

if [[ "$DRY_RUN" == "true" ]]; then
    print_warning "DRY RUN MODE - No PRs will be created"
fi

echo ""

# Array to store created branch names for cleanup on error
CREATED_BRANCHES=()

# Function to cleanup branches on error
cleanup_on_error() {
    if [[ ${#CREATED_BRANCHES[@]} -gt 0 ]]; then
        print_warning "Cleaning up created branches..."
        for branch in "${CREATED_BRANCHES[@]}"; do
            git branch -D "$branch" 2>/dev/null || true
        done
    fi
    git checkout "$CURRENT_BRANCH" 2>/dev/null || true
}

# Set trap for cleanup
trap cleanup_on_error ERR

# Process each commit
PREVIOUS_BRANCH="$BASE_BRANCH"
PR_URLS=()

for i in "${!COMMITS[@]}"; do
    COMMIT="${COMMITS[$i]}"
    COMMIT_SHORT=$(git rev-parse --short "$COMMIT")
    COMMIT_MSG=$(git log -1 --pretty=format:"%s" "$COMMIT")
    BRANCH_NAME="${BRANCH_PREFIX}-${i}"

    print_info "Processing commit $((i + 1))/${#COMMITS[@]}: $COMMIT_SHORT - $COMMIT_MSG"

    if [[ "$DRY_RUN" == "true" ]]; then
        echo "  Would create branch: $BRANCH_NAME"
        echo "  Would base on: $PREVIOUS_BRANCH"
        echo "  Would create PR: $COMMIT_MSG"
        echo ""
        PREVIOUS_BRANCH="$BRANCH_NAME"
        continue
    fi

    # Create and checkout new branch based on the commit
    print_info "  Creating branch $BRANCH_NAME from $COMMIT"
    git checkout -b "$BRANCH_NAME" "$COMMIT"
    CREATED_BRANCHES+=("$BRANCH_NAME")

    # Push the branch
    print_info "  Pushing branch $BRANCH_NAME"
    git push -u origin "$BRANCH_NAME"

    # Prepare PR body
    COMMIT_BODY=$(git log -1 --pretty=format:"%b" "$COMMIT")
    PR_BODY="$COMMIT_BODY"

    if [[ $i -gt 0 ]]; then
        PREV_PR_NUM=$(gh pr list --base "$PREVIOUS_BRANCH" --head "${CREATED_BRANCHES[$((i - 1))]}" --json number --jq '.[0].number' 2>/dev/null || echo "")
        if [[ -n "$PREV_PR_NUM" ]]; then
            PR_BODY="$PR_BODY

This PR is part of a stack. It depends on:
- #$PREV_PR_NUM"
        else
            PR_BODY="$PR_BODY

This PR is part of a stack. It depends on the PR for branch: ${CREATED_BRANCHES[$((i - 1))]}"
        fi
    fi

    # Create PR
    print_info "  Creating PR: $COMMIT_MSG"
    PR_URL=$(gh pr create \
        --title "$COMMIT_MSG" \
        --body "$PR_BODY" \
        --base "$PREVIOUS_BRANCH" \
        --head "$BRANCH_NAME")

    PR_URLS+=("$PR_URL")
    print_success "  Created PR: $PR_URL"

    # Update previous branch for next iteration
    PREVIOUS_BRANCH="$BRANCH_NAME"

    echo ""
done

# Return to original branch
git checkout "$CURRENT_BRANCH"

# Clear trap
trap - ERR

# Print summary
echo ""
print_success "Successfully created ${#PR_URLS[@]} stacked PRs:"
for i in "${!PR_URLS[@]}"; do
    echo "  $((i + 1)). ${PR_URLS[$i]}"
done

echo ""
print_info "Stack structure:"
print_info "  $BASE_BRANCH (base)"
for i in "${!CREATED_BRANCHES[@]}"; do
    if [[ $i -eq 0 ]]; then
        echo "    ↳ ${CREATED_BRANCHES[$i]} → $BASE_BRANCH"
    else
        echo "    ↳ ${CREATED_BRANCHES[$i]} → ${CREATED_BRANCHES[$((i - 1))]}"
    fi
done

echo ""
print_warning "To merge the stack:"
print_info "1. Review and merge the bottom PR first (${PR_URLS[0]})"
print_info "2. GitHub will automatically update the base of dependent PRs"
print_info "3. Continue merging from bottom to top"

echo ""
print_warning "To clean up branches after merging:"
echo "git branch -d ${CREATED_BRANCHES[*]}"
echo "git push origin --delete ${CREATED_BRANCHES[*]}"
